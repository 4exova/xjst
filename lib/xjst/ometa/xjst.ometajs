var ometajs = require('ometajs'),
    xjst = require('../../xjst'),
    utils = xjst.utils,

    Identifier = utils.Identifier,
    BSJSParser = ometajs.BSJSParser,
    BSJSTranslator = ometajs.BSJSTranslator,
    BSJSIdentity = ometajs.BSJSIdentity;

ometa XJSTParser <: BSJSParser {

    isKeyword :x = ?(BSJSParser._isKeyword(x) || x === 'local' || x === 'apply' || x === 'template'),

    primExprHd = "local" "(" expr:a ")" expr:b localExpr([#local, a, b]):r -> r
        | "apply" "(" ")" applyStmt([#apply]):st -> st
        | "apply" "(" expr:a ")" applyStmt([#apply]):st
                                 localExpr([#local, a, st]):r -> r
        | "apply" applyExpr([#apply]):expr -> expr
        | ^primExprHd,

    stmt = "local" "(" expr:a ")" stmt:b localStmt([#local, a, b]):r -> r
        | "apply" "(" ")" applyStmt([#apply]):st -> st
        | "apply" "(" expr:a ")" applyStmt([#apply]):st
                                 localStmt([#local, a, st]):r -> r
        | ^stmt,

    template = "template" "(" expr:m ")" stmt:b -> [#template, m, b],

    applyStmt = [#apply] -> [#applyStmt, {}],
    applyExpr = [#apply] -> [#applyExpr],

    localStmt = [#local :a :b] -> [#localStmt, a, b],
    localExpr = [#local :a :b] -> [#localExpr, a, b],

    topLevel = (template:t -> t | srcElem:s -> [#stmt, s])+:ts spaces end -> ts
}

ometa XJSTTranslator <: BSJSIdentity {

    const = [#string :s] | [#number :n],

    applyStmt :p -> [#applyStmt, p],
    applyExpr -> [#applyExpr],

    localStmt localAsmts:as trans:t -> {
            [#begin].concat(
                [[#localStart, XJSTTranslator._localToPred(this.identifier, as)]],
                as[0],
                [t],
                as[1],
                [[#localEnd]]
            );
        },

    localExpr localAsmts:as trans:t -> {
            var prelude = [
                  [#localStart, XJSTTranslator._localToPred(this.identifier, as)]
                ],
                result = XJSTTranslator._getLocalVar(this),
                self = this;

            as[0].forEach(function(e) {
              if (e[0] === 'var') {
                e.slice(1).forEach(function(v) {
                  self._vars.push([v[0]]);
                  prelude.push([#set, [#get, v[0]], v[1]]);
                });
              } else {
                prelude.push(e);
              }
            });

            [].concat(
                prelude,
                [[#set, result, t]],
                as[1],
                [[#localEnd], result]
            ).reduce(function(a, i) {
                return a ? [#binop, ",", a, i] : i;
            });
        },

    localAsmts = localAsmt:e1 -> e1
        | [#binop ',' localAsmts:es localAsmt:e2] -> {
            es.forEach(function(e, i) {
                es[i] = e.concat(e2[i]);
            });
            es
        },

    localAsmt = [#set [(#get :n | #getp :k :o)]:p :v]
                localProps(p):props -> {
            var lv = XJSTTranslator._getLocalVar(this),
                vars = [[#var].concat(props[1], [[lv[1], props[0]]])];

            [
                vars.concat([[#set, props[0], v]]),
                [[#set, props[0], lv]],
                [[p, v]]
            ]
        },

    localProps = [#getp const:k :o]:expr -> [expr, []]
                 | [#getp :k [#this]] -> {
                     var v = XJSTTranslator._getLocalVar(this);

                     [ [#getp, v, [#this]], [[v[1], k]] ]
                 }
                 | [#call anything*:args]:expr -> {
                     var v = XJSTTranslator._getLocalVar(this);

                     [
                        expr,
                        [[v[1], expr]]
                     ]
                 }
                 | [#getp :k localProps:o] -> {
                     var v = XJSTTranslator._getLocalVar(this);

                    [
                        [#getp, v, o[0]],
                        [[v[1], k]].concat(o[1])
                    ]
                 }
                 | :expr -> [expr, []],

    subMatch = [#binop '===' :e1 const:c] -> [e1, c] |
        [#binop '===' const:c :e2] -> [e2, c] |
        :e3 -> [[#unop, '!', e3], [#get, #false]],

    expr2match = [#binop '&&' expr2match:ms subMatch:m1] -> { ms.push(m1); ms} |
        subMatch:m2 -> [m2] ,

    template :m trans:b -> [
                                #template,
                                [XJSTTranslator.match(m, #expr2match), b]
                             ],
    stmt trans:s -> [#stmt, s],

    topLevel = { this._vars = []; this.identifier = new Identifier(); }
        trans*:ts -> {

        if (this._vars.length) {
           this._vars.unshift(#var);
           ts.unshift([#stmt, this._vars]);
        }

        XJSTTranslator._splitTemplates(this.identifier, ts);
    }

}

XJSTTranslator._getLocalIdCounter = 0;
XJSTTranslator._getLocalId = function() {
  return this._getLocalIdCounter++;
};
XJSTTranslator._getLocalVar = function(p) {
    var id = this._getLocalId();
    return [#get, '__r' + id];
};

XJSTTranslator._localToPred = function(identifier, as) {
  return as[2].map(function(as) {
    as = [identifier.identify(as[0]), as[0], as[1]];
    if (as[2][0] !== 'string' && as[2][0] !== 'number') {
      return [as[0], as[1], 'reset'];
    } else {
      return as;
    }
  });
};

XJSTTranslator._splitTemplates = function(predicates, ts) {
    var templates = [],
        other = [],
        i;

    while(i = ts.shift())
        i[0] == 'template'?
            templates.unshift(i[1]) :
            other.push(i[1]);

    return [other, XJSTTranslator._identify(predicates, templates)];
};

XJSTTranslator._identify = function(predicates, templates) {
    templates.forEach(function(template) {
        template[0].forEach(function(subMatch) {
            subMatch.unshift(predicates.identify(subMatch[0]));
        })
    });

    return templates;
};

ometa XJSTLocalAndApplyCompiler <: BSJSIdentity {
    applyStmt = :p -> { this.result.push(['apply', p]); [#applyStmt, p] },
    applyExpr = [#applyExpr],

    localStart = :as -> { this.result.push(['localStart', as]); [#localStart, as] },
    localEnd -> { this.result.push(['localEnd']); [#localEnd] },

    topLevel = { this.result = []; } trans:t { this.result; }
}

ometa XJSTCompiler <: BSJSTranslator {

    applyStmt = :param -> { param.code || 'apply.call(this)' },
    applyExpr -> 'apply',

    localStmt = trans:a trans:b -> { 'local (' + a + ') ' + b + ';' },
    localExpr = trans:a trans:b -> { 'local (' + a + ') ' + b },

    localStart = :as -> 'undefined',
    localEnd -> 'undefined',

    subMatch = [:id trans:m [#get #true]] -> m |
        [:id trans:e trans:c] -> (e + ' === ' + c),

    tMatch = [subMatch:m] -> m |
        [subMatch+:ms] -> ms.join(' && '),

    tBody = trans:e -> e,

    template = [tMatch:m tBody:b] -> ('if(' + m + ') {' + b + ';return}'),

    templates = [template*:ts] -> ('exports.apply = function(c) {\n' + ts.join('\n') +'\n};'),

    other = [trans*:o] -> o.join(';'),

    topLevel = [other:o templates:t] -> {
        '(function(exports) {' +
        o + ';' + t +
        'return exports})(typeof exports === "undefined"? {} : exports)' }

}
