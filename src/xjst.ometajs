ometa XJSTParser <: BSJSParser {

    const = [#string :s] | [#number :n],

    isKeyword :x = ?(BSJSParser._isKeyword(x) || x == 'local'),

    stmt = "local" "(" expr:c ")" stmt:t -> XJSTParser.match([#local, c, t], 'local')
        | ^stmt,

    local = [#local localExprs:es :t] -> {
            var id = XJSTParser._getLocalId(), res = [#begin];
            es.forEach(function(x){ res.push.apply(res, x[0]) });
            res.push(t);
            es.reverse().forEach(function(x){ res.push.apply(res, x[1]) });
            res;
        },

    localExprs = localExpr:e1 -> [e1] |
        [#binop ',' localExprs:es localExpr:e2] -> { es.push(e2); es },

    localExpr = [#set [#get :n]:p :v] -> {
            var id = XJSTParser._getLocalId();
            [
                [
                    [#var, ['__v' + id, p]],
                    [#set, [#get, n], v]
                ],
                [
                    [#set, [#get, n], [#get, '__v' + id]]
                ]
            ]
        } |
        [#set [#getp const:k :o]:p :v] -> {
            var id = XJSTParser._getLocalId(),
                vTree = [#getp, k, [#get, '__o' + id]];
            [
                [
                    [#var,
                        ['__o' + id, o],
                        ['__v' + id, vTree]],
                    [#set, vTree, v]
                ],
                [
                    [#set, vTree, [#get, '__v' + id]]
                ]
            ]
        } |
        [#set [#getp :k :o]:p :v] -> {
            var id = XJSTParser._getLocalId(),
                vTree = [#getp, [#get, '__k' + id], [#get, '__o' + id]];
            [
                [
                    [#var,
                        ['__o' + id, o],
                        ['__k' + id, k],
                        ['__v' + id, vTree]],
                    [#set, vTree, v]
                ],
                [
                    [#set, vTree, [#get, '__v' + id]]
                ]
            ]
        },

    tBody = stmt,

    subMatch = [#binop '===' :e1 const:c] -> [e1, c] |
        [#binop '===' const:c :e2] -> [e2, c] |
        :e3 -> [[#unop, '!', e3], [#get, #false]],

    expr2match = [#binop '&&' expr2match:ms subMatch:m1] -> { ms.push(m1); ms} |
        subMatch:m2 -> [m2] ,

    tMatch = expr:ms -> XJSTParser.match(ms, #expr2match),

    template = tMatch:m spaces tBody:b -> [m, b],

    topLevel = template+:r '\n'* end -> XJSTParser._identify(r)

}

XJSTParser._getLocalIdCounter = 0;
XJSTParser._getLocalId = function() {
    return this._getLocalIdCounter++;
};


XJSTParser._identify = function(templates) {
    var predicates = new Identifier();
    templates.forEach(function(template) {
        template[0].forEach(function(subMatch) {
            subMatch.unshift(predicates.identify(subMatch[0]));
        })
    });
    return templates;
};

ometa XJSTBeautifier {

    trans = [:t apply(t):ans] -> ans,

    curlyTrans = [#begin curlyTrans:r] -> r |
        [#begin trans*:rs] -> ('{ ' + rs.join(';') + ' }') |
        trans:r -> ('{ ' + r + ' }'),

    nameString = :n ?(XJSTParser.matchAll(n, 'name')[1] == n) -> n,

    this -> 'this',
    break -> 'break',
    continue -> 'continue',

    number :n -> n,
    string :s -> s.toProgramString(),
    arr trans*:xs -> ('[' + xs.join(', ') + ']'),
    unop :op trans:x -> (op + x),
    getp (
            [#string nameString:n] -> ('.' + n) |
            trans:fd -> ('[' + fd + ']')
        ):p
        trans:x -> (x + p),
    get :x -> x,
    set trans:lhs trans:rhs -> (lhs + ' = ' + rhs),
    mset trans:lhs :op trans:rhs -> (lhs + ' ' + op + '= ' + rhs),
    binop :op trans:x trans:y -> (x + ' ' + op + ' ' + y),
    preop :op trans:x -> (op + x),
    postop :op trans:x -> (x + op),

    return trans:x -> ('return ' + x),
    with trans:x curlyTrans:s -> ('with(' + x + ')' + s),
    if trans:cond curlyTrans:t curlyTrans:e -> ('if(' + cond + ')' + t + ' else ' + e),
    condExpr trans:cond trans:t trans:e -> ('(' + cond + ' ? ' + t + ' : ' + e + ')'),
    while trans:cond curlyTrans:body -> ('while(' + cond + ')' + body),
    doWhile curlyTrans:body trans:cond -> ('do' + body + 'while(' + cond + ')'),
    for trans:init trans:cond trans:upd
    curlyTrans:body -> ('for(' + init + ';' + cond + ';' + upd + ')' + body),
    forIn trans:x trans:arr curlyTrans:body -> ('for(' + x + ' in ' + arr + ')' + body),
    begin trans:x end -> x,
    begin (trans:x
            ( (?(x[x.length - 1] == '}') | end) -> x
                | empty -> (x + ';')
            )
        )*:xs -> ('{' + xs.join('') + '}'),
    func :args curlyTrans:body -> ('(function (' + args.join(', ') + ')' + body + ')'),
    call trans:fn trans*:args -> (fn + '(' + args.join(', ') + ')'),
    send :msg trans:recv trans*:args -> (recv + '.' + msg + '(' + args.join(', ') + ')'),
    new :cls trans*:args -> ('new ' + cls + '(' + args.join(', ') + ')'),
    var ([:n trans:v] -> (n + ' = ' + v))+:vs -> ('var ' + vs.join(',')),
    throw trans:x -> ('throw ' + x),
    try curlyTrans:x :name curlyTrans:c curlyTrans:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f),
    json trans*:props -> ('{ ' + props.join(', ') + ' }'),
    binding (
            nameString |
            :n2 -> n2.toProgramString()
        ):name
        trans:val -> (name + ': ' + val),
    switch trans:x trans*:cases -> ('switch(' + x + '){' + cases.join(';') + '}'),
    case trans:x trans:y -> ('case ' + x + ': '+ y),
    default trans:y -> ('default: ' + y),

    subMatch = [:id trans:m [#get #true]] -> m |
        [:id trans:e trans:c] -> (e + ' == ' + c),

    tMatch = [subMatch:m] -> m |
        [subMatch+:ms] -> ms.join(' && '),

    tBody = trans:e -> ('\n    ' + e),

    template = [tMatch:m tBody:b] -> (m + b),

    topLevel = template+:ts -> ts.join('\n\n')

}

ometa XJSTCompiler <: BSJSTranslator {

    subMatch = [:id trans:m [#get #true]] -> m |
        [:id trans:e trans:c] -> (e + ' === ' + c),

    tMatch = [subMatch:m] -> m |
        [subMatch+:ms] -> ms.join(' && '),

    tBody = trans:e -> e,

    template = [tMatch:m tBody:b] -> ('    if(' + m + ') {' + b + ';return}'),

    topLevel = template+:ts -> ('(function(c){\n' + ts.join('\n') +'\n})'),

    topLevel2 = :ts -> XJSTCompiler.matchAll(ts.reverse(), 'topLevel2')

}
